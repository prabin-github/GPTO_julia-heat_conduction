# --------------------------------------------------------------------------------
# Sets up all parameters for the optimization, indicating mesh, BCs, material,
# geometry, solver, and optimization settings. Customize per problem.
# --------------------------------------------------------------------------------

## Input file 
#
# *** THIS SCRIPT HAS TO BE CUSTOMIZED BY THE USER ***
#
# This script sets up all the parameters for the optimization, and also
# indicates what files contain the mesh, boundary conditions, and initial
# design.
#
#
# It is recommended that for different problems you make copies of this
# file in the input_files subfolder, so that to switch from one problem to
# another you need only change the run statement in the inputs.m file in
# the root folder.
#


# ** Do not modify this line **
# global FE, OPT, GEOM

# Declare globals (const binding for performance; contents still mutable)
const FE = Dict{Symbol, Any}()
const OPT = Dict{Symbol, Any}()
const GEOM = Dict{Symbol, Any}()

# Problem name
OPT[:problem] = "heat_conduction2D"

# Display problem name on screen
println("\nStarting...\nProblem: $(OPT[:problem])\n")

# Set this flag to true if you want plotting during the optimization
plot_cond = true

## =======================================================================
## Mesh information
#
# First of all, an important clarification: in this code, we refer to mesh
# as exclusively the nodal coordinates and the element nodal connectivity
# array. You have to write/modify a separate matlab script (setup_bcs) to
# set up the loads and displacement boundary conditions).
#
# This code provides three options to populate a mesh, indicated in the
# FE[:mesh_input][:type] field: "generate","read-home-made", and "read-gmsh":
#
# 1- "generate": Generate a rectangular/parallelepiped mesh on the fly by
#                providing the dimensions and element size (using the
#                generate_mesh function).
# 2- "read-home-made": Load mesh from Matlab .mat file
#                      (which you can create before running this code using
#                      the makemesh function).
# 3- "read-gmsh":  Read quadrilateral or hexahedral mesh generated by Gmsh
#                  and exported to the Matlab format. For this code, we
#                  tested version 4.0.6 of Gmsh (but it is possible that
#                  earlier versions work if so, try at your own risk).
#
FE[:mesh_input] = Dict{Symbol, Any}()
FE[:mesh_input][:type] = "generate"

# If mesh input type is "generate", you must specify the dimensions of
# the rectangle/cuboid and the number of elements along each direction:
FE[:mesh_input][:box_dimensions] = [100.0, 100.0]
FE[:mesh_input][:elements_per_side] = [100, 100]

# If mesh input type is "read-home-made", you must provide a
# mesh file name including extension (*.mat).
# 
# NOTE: all folders are relative to the root folder where the GPTO_b.m
# script is located.
#
FE[:mesh_input][:mesh_filename] = "input_files/heat_conduction2D/2drectangle.mat"

# If mesh input type is "read-gmsh", you must provide a
# mesh file name including extension (*.m). To produce this file, you must
# first generate a transfinite mesh (only quad elements in 2-d, only hexa
# elements in 3-d) in Gmsh, and then export it with Matlab format
# (including the .m extension).
FE[:mesh_input][:gmsh_filename] = "input_files/heat_conduction2D/heat_conduction2D.jl"

## =======================================================================
## Boundary conditions

# Here, you must specify the path to a Matlab script file that sets up the
# boundary conditions (which you must modify according to the problem)
FE[:mesh_input][:bcs_file] = "input_files/heat_conduction2D/setup_bcs_heat_conduction2D.jl"

## =======================================================================
## Material information
#
# Specify the thermal conductivity
FE[:material] = Dict{Symbol, Any}(
    :Kt       => 1.0,    # Thermal conductivity of the design material
    :rho_min  => 1e-3,   # Minimum density in void region
    :Kt_min   => 0.001   # Thermal conductivity of the void material
)

## =======================================================================
## Initial design (geometry)
# This flag allows you to use an initial design saved in a previous ru
# If restart = False, this path should be the path to a Matlab script
# that initializes the geometry otherwise, it should be the path to a
# .mat file previously saved by the code
GEOM[:initial_design] = Dict{Symbol, Any}(
    :path     => "input_files/heat_conduction2D/initial_heat_conduction2D_geometry.jl",
    :plot     => plot_cond,
    :restart  => false
)

# You must specify the lower and upper bounds on the bar radius.  If you 
# want a design with fixed bar radii, simply set both fields to the same
# value.
GEOM[:min_bar_radius] = 1.0
GEOM[:max_bar_radius] = 5.0

## =======================================================================    
## Finite element solver
FE[:analysis] = Dict{Symbol, Any}()
FE[:analysis][:solver] = Dict(
    :type    => "direct",      # Options: "direct" or "iterative"
    :tol     => 1e-5,          # only for iterative
    :maxit   => 1e4,           # only for iterative
    :use_gpu => false
)
# NOTE: gpus can only be used if:
# (a) FE[:analysis][:solver][:type] = "iterative"
# (b) the system has a compatible nvidia gpu (and drivers)
#     You can query your system's gpu with the matlab command
#     >> gpuDevice()
# The gpu solver may be slower than an iterative solver on the cpu for
# smaller problems because of the cost to transfer data to the gpu. 
    
## =======================================================================        
## Optimization problem definition
# functions:
OPT[:functions] = Dict{Symbol, Any}()
# Name of objective function
OPT[:functions][:objective] = "compliance"
# Names of inequality (<=) constraints
OPT[:functions][:constraints] = "volume fraction"
# Inequality constraint (upper) limits vector: should have the
# constraint limit for each one of the constraints.
OPT[:functions][:constraint_limit] = [0.3]

## =======================================================================        
## Geometry projection parameters
# Sample window radius.  By default, the routine init_optimization
# computes this radius as sqrt(FE['dim)/2 * FE['elem_vol.^(1./FE['dim),
# which corresponds to the radius of the circle (in 2-d) or sphere (in
# 3-d) that circumscribes a square or cube element.  If you uncomment
# the following line, you can override this value (if you do, then the
# value corresponds to the actual radius dimension).
# 
OPT[:parameters] = Dict{Symbol, Any}()
# OPT[:parameters][:elem_r] = .1   # Eq. (34)
#
# Type of smooth maximum function for aggregation (Boolean union)
# Options are: "mod_p-norm", "mod_p-mean", "KS", and "KS_under"
OPT[:parameters][:smooth_max_scheme] = "mod_softmax"
# Parameter to be used for the smooth_max function
OPT[:parameters][:smooth_max_param] = 24
# Penalization scheme 
OPT[:parameters][:penalization_scheme] = "RAMP"  # Options: 'SIMP', 'RAMP' 
# Parameter to be used for the penalization
OPT[:parameters][:penalization_param] = 3

## =======================================================================        
## Optimization parameters
OPT[:options] = Dict{Symbol, Any}()
# Optimizer (options: "default" and "mma")
# OPT[:options][:optimizer] = "default"
OPT[:options][:optimizer] = "mma"
# Whether plots should be produced or not 
OPT[:options][:plot] = plot_cond
# Write to a vkt file options are "none", "last" (only write last 
# iteration)and "all" (write all iterations).  
OPT[:options][:write_to_vtk] = "last"
# Recall that paths are relative to the root folder 
OPT[:options][:vtk_output_path] = "output_files"
# whether to scale the design variables to the range [0,1]
OPT[:options][:dv_scaling] = true
# Move limits as a fraction of the range between bounds 
OPT[:options][:move_limit] = 0.1
# Maximum number of iterations 
OPT[:options][:max_iter] = 100
# Minimum step size in design
OPT[:options][:step_tol] = 1e-3
# Convergence tolerance on KKT norm
OPT[:options][:kkt_tol] = 1e-4

## =======================================================================        
## Sensitivities finite difference check
#
# These options allow you to run a finite difference check on the cost
# function, and/or the constraint.
#
# Please note that if you do a finite difference check, the code will stop
# right after the check and not continue with the optimization (typically
# you want to do one or the other but not both).
#
# Whether or not to perform sensitivities finite difference check
OPT[:make_fd_check] = false
# Step size for finite difference
OPT[:fd_step_size] = 1e-7
# Whether or not to check cost function sensitivities
OPT[:check_cost_sens] = true
# Whether or not to check constraint sensitivities
OPT[:check_cons_sens] = true

# --------------------------------------------------------------------------------
# End of inputs_heat_conduction2D.jl
# --------------------------------------------------------------------------------
