function generate_mesh(FE,OPT,GEOM)
    #
    # This function generates a uniform quadrilateral or hexahedral mesh for 
    # rectangular or parallelepiped design regions respectively. 
    #
    # The two arguments needed (box_dimensions & elements_per_side) must have
    # been assigned in the FE["mesh_input structure prior to calling this
    # routine.
    #
    # box_dimensions is a vector (2 x 1 in 2D, 3 x 1 in 3D) with the dimensions
    #                of the design region.
    # elements_per_side is a vector of the same dimensions as box_dimensions
    #                   with the number of elements to be created in each
    #                   corresponding dimension.
    #
    # The function updates the necessary arrays in the global FE structure.
    # This function does not need modification from the user.
    #

    #global FE

    box_dimensions = FE[:mesh_input][:box_dimensions]
    elements_per_side = FE[:mesh_input][:elements_per_side]

    # A sanity check:
    if length(box_dimensions) != length(elements_per_side)
        error("Inconsistent number of dimensions and elements per side.")
    end

    if length(box_dimensions) == 3
        FE[:dim] = 3
    elseif length(box_dimensions) == 2
        FE[:dim] = 2
    else
        error("FE[\"mesh_input\"][\"dimensions\"] must be of length 2 or 3")
    end

    ## create nodal coordinates
    FE[:n_elem] = prod(elements_per_side[1:FE[:dim]])
    FE[:n_node] = prod(elements_per_side[1:FE[:dim]] .+ 1)

    ## define element connectivity
    nelx = elements_per_side[1]
    nely = elements_per_side[2]

    # ==== FE model generation ===
    # Mesh generation
    domain = (0,float(nelx),0,float(nely))
    partition = (nelx,nely)
    GEOM[:model] = CartesianDiscreteModel(domain,partition)

    node_coords = Geometry.get_node_coordinates(GEOM[:model])
    A = collect(node_coords)
    X = getindex.(A,1)
    Y = getindex.(A,2)
    FE[:coords] = [vec(X)';
                    vec(Y)']

    trian = Triangulation(GEOM[:model])
    D = num_cell_dims(GEOM[:model])
    topo = get_grid_topology(GEOM[:model])
    cell_vertex_ids = Geometry.get_faces(topo, D, 0)
    FE[:elem_node] = hcat(cell_vertex_ids...)

    dim = FE[:dim] 
    CoordArray = zeros(2^dim, dim, FE[:n_elem])

    for n in 1:FE[:n_elem]
        CoordArray[:, :, n] = transpose(FE[:coords][:, FE[:elem_node][:, n]])
    end

    FE[:centroids] = reshape(mean(CoordArray, dims=1), (FE[:dim], FE[:n_elem]))

    FE[:elem_vol] = get_cell_measure(trian)

    FE[:coord_max] = maximum(FE[:coords], dims=2)[:]
    FE[:coord_min] = minimum(FE[:coords], dims=2)[:]

    ## print to terminal details of mesh generation
    @printf("generated %dD cuboid mesh with %d elements & %d nodes...\n",
        FE[:dim], FE[:n_elem], FE[:n_node])
end


function read_gmsh(FE,OPT,GEOM)
    # This function reads a mesh in Matlab format generated using Gmsh and
    # stores the node coordinates and element connectivity in the global FE
    # structure. 
    #
    # The name of the Matlab .m file (which must include extension) should be
    # previously stored in FE['mesh_input.gmsh_filename.
    #
    # This function has been tested with Gmsh v. 4.0.7.  Gmsh is distributed
    # under the terms of the GNU General Public License (GPL), and can be
    # downloaded from
    #
    # gmsh.info
    #

    # *** Do not modify this code unless necessary **
    include(FE[:mesh_input][:gmsh_filename])

    # Note we assume the Matlab file generated by Gmsh creates a structure
    # named msh, and that this structure is available in the workspace for our
    # code to then grab.

    # If HEXAS elements are not present, then assume the mesh is 2D (in that
    # case, the field msh.QUADS must exist
    if haskey(msh, :HEXAS)
        FE[:dim] = 3
        el_array = msh[:HEXAS]
    else
        FE[:dim] = 2
        el_array = msh[:QUADS]
    end

    # at this point, there is no garuntee that the element nodes are in the
    # correct order for this code. We assume that the ordering of nodes yields
    # a positive determinant, so we must now ensure that this is the case.

    nodes_per_elem = 2^FE[:dim]
    coords = permutedims(msh[:POS][:,1:FE[:dim]])
    elem_node = permutedims(el_array[:,1:nodes_per_elem])

    # Ensure element node ordering is correct for 2D
    if FE[:dim] == 2
        nelem = size(elem_node, 2)
        e_coord = reshape(coords[:, elem_node], (FE[:dim], nodes_per_elem, nelem))

        # ensure that elemnt nodes 1,2,3 are in ccw order:
        hom_coord_123 = ones(3, 3, nelem)
        hom_coord_123[1:2, 1:3, :] .= e_coord[:, 1:3, :]

        cross_products = mapslices(
            M -> dot(cross(M[:,1], M[:,2]), M[:,3]),   # M is now 3×3
            hom_coord_123;
            dims = (1, 2))                             # slice over first two dims → M[:,:,i]
        
        cw = findall(x -> x < 0, cross_products[:])

        # swap nodes 2 and 4 of the cw elements
        elem_node[2, cw], elem_node[4, cw] = elem_node[4, cw], elem_node[2, cw]
    else
        println("Not yet verified that the element nodes are in the canonical order")
    end

    # Populate appropriate fields in FE structure
    FE[:n_node]    = msh[:nbNod]
    FE[:n_elem]    = size(el_array,1)
    FE[:coords]    = coords
    FE[:elem_node] = elem_node
end